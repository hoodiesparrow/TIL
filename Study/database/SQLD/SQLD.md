SQLD

## 공부 방법

- 절 by 절 단계로 진행 [5, 6, 9, 8, 3] :: 총 31절
  - 개념 학습
    - 학습 내용 정리
      - 문제 풀이
        - 해설지 학습
        - 활용 파트 -> 문제풀이 동영상 시청
- 마무리는 양치기 한번 해야할 것 같음
  - 이건 온라인에 있는 문제들 쭉 읽어보면 될 것 같음



## 1장_데이터 모델링의 이해

### 1절_데이터 모델의 이해

1. 모델링 :: 현실세계를 단순화하여 표현하는 것
   - 특징
     - 추상화: 일정한 형식에 맞춰 표현
     - 단순화: 제한된 표기법이나 언어로 표현
     - 명확성: 이해가 쉽게 표현
   - 관점
     - 데이터 관점: 업무-데이터, 데이터-데이터 사이의 관계
     - 프로세스 관점: 진행중 또는 진행되어야 하는 업무
     - 상관 관점: 데이터에 대한 업무 처리 방식의 영향
2. 데이터 모델링 :: 정보 시스템 구축을 위한 데이터 관점의 업무 분석 기법
   - 목적
     - 정보에 대한 표기법을 통일하여 업무 내용 분석 정확도 향상
     - 데이터 모델을 기반으로 DB 생성
   - 기능
     - 가시화
     - 명세화
     - 구조화된 틀 제공
     - 문서화
     - 다양한 관점 제공
     - 구체화
   - 중요성
     - 파급효과
     - 간결한 표현 (정보 요구사항 및 한계를 간결하게 표현하는 도구)
     - 데이터 품질
       - 유일성: 데이터 중복 저장 방지
       - 유연성: 데이터 정의와 데이터 사용 프로세스 분리
       - 일관성
     - 이해관계자
       - 개발자
       - DBA
       - 모델러
       - 현업 업무 전문가
3. 데이터 모델링 3단계
   - 개념적 모델링: 엔티티와 속성을 도출, ERD 작성 => 업무 중심적이며 포괄적인 수준의 모델링
     - 즉 ERD 그리면서 대강의 그림 그리는 단계
   - 논리적 모델링: 식별자를 도출하고 속성, 관계 등을 정의. 정규화를 수행하여 데이터 모델의 독립성과 재사용성 확보, 논리 데이터 모델은 데이터 모델링 완료된 상태
     - 실제 사용될 식별자 및 정규화를 위해 속성과 관계를 정리하는 단계
   - 물리적 모델링: DB를 실제로 구축, 성능 및 보안 등 물리적인 성격을 고려
   - +) 프로젝트 생명주기 **(? 정확한 것 맞나)**
     - 계획 - 분석 - 설계 - 개발 - 테스트 - 전환/이행
       - 계획, 분석 => 개념적 모델링
       - 분석 => 논리적 모델링
       - 개발 => 물리적 모델링
4. DB의 3단계 구조 :: 데이터 독립성 확보가 목표
   - DB 독립성의 필요성
     - 데이터의 중복성과 데이터 복잡도 증가
       - 유지보수 비용 증가
       - 요구사항 대응 저하
   - 3층 스키마
     - 외부 스키마: 각 사용자 단계의 개인적 DB 스키마, 사용자 관점, 응용 프로그램이 접근하는 DB를 정의
       - API같은 개념일까
     - 개념 스키마: 조직 전체의 통합된 DB 스키마, 설계자 관점 (데이터 모델링의 지향점)
     - 내부 스키마: 물리적으로 데이터가 저장되는 방법을 표현하는 스키마, 개발자 관점, 물리적 저장 구조
   - 데이터 독립성
     - 논리적 독립성: 외부 스키마**가** 개념 스키마의 변화에 무관함, 논리적 사상 없음
     - 물리적 독립성: 개념 스키마**가** 내부 스키마의 변화에 무관함, 물리적 사상 없음
       - 이건 알겠다. 샤딩을 한다고 해서 스키마에 영향을 주지는 않는다...같은 개념
5. 데이터 모델링 **3요소** :: 엔티티, 관계, 속성
6. ERD
   - 엔티티는 사각형, 관계는 마름모, 속성은 타원형으로 표현. 현실의 데이터를 모두 표현 **가능**하다.
     - 엔티티 도출
       - 엔티티 배치
         - 엔티티 간 관계 설정
           - 관계명 기술
             - 관계 차수(1:1, 1:N, N:M) 표현
               - 관계선택사양(필수, 선택) 표현
7. 좋은 모델링의 요건
   - 완전성
   - 중복 배제
   - 업무 규칙
   - 데이터 재사용
   - 의사소통
   - 통합성

### 2절_엔티티

1. 정의 :: 업무에서 관리해야 하는 데이터의 **집합**, 명사형, 인스턴스의 집합
2. 특징
   - 업무에서 필요로 함
   - 유일한 식별자를 가짐
   - 2개 이상의 인스턴스를 포함함
   - 업무 프로세스에 이용됨
   - 속성을 가짐
   - 관계를 가짐
3. 종류
   - 유무형에 따른 분류
     - 유형 엔티티: 물리적 형태가 있고 지속적으로 활용되는 엔티티
     - 개념 엔티티: 물리적 형태가 없는 엔티티
   - 발생시점에 따른 분류
     - 기본 엔티티: 독립적으로 생성되는 엔티티
     - 중심 엔티티: 기본 엔티티와 행위 엔티티의 중간에 존재하는 엔티티
     - 행위(사건) 엔티티: 2개 이상의 부모 엔티티로부터 발생. 비즈니스 프로세스를 실행하며 생성됨. 지속적으로 정보가 추가되고 변경되어 데이터양이 가장 많음
4. 명명 규칙
   - 현업에서 사용되는 용어
   - 약어 지양
   - 단수 명사
   - 유일성 보장
   - 명확성

### 3절_속성

1. 정의 :: 엔티티가 가지는 최소 의미 단위, 인스턴스의 구성 요소
2. 엔티티와 인스턴스 및 속성과 속성값 간의 관계 (그림참조)
3. 속성 표기법: IE 표기법, Barker 표기법
4. 특징
   - 업무에서 필요하고 관리하고자 하는 정보
   - 주식별자에 함수적으로 종속됨
   - 속성값 하나만 가짐 (하나 이상의 속성값이면, 정규화 필요)
5. 종류 (복습필요)
   - 특성에 따른 분류
     - 기본 속성: 비즈니스 프로세스에서 도출되는 본래의 속성
     - 설계 속성: 데이터 모델링 과정에서 업무 규칙화를 위해 발생하는 속성
     - 파생 속성: 다른 속성에 의해 만들어지는 속성 (저장 속성은 유도 속성을 생성하는 데 사용되는 속성)
   - 분해 가능 여부에 따른 분류
     - 단일 속성: 하나의 의미
     - 복합 속성: 여러 의미, 단일 속성으로 분해 가능 (주소)
     - 단일값 속성: 하나의 값
     - 다중값 속성: 여러 값, 엔티티로 분해 가능
   - 엔티티 구성방식에 따른 분류
     - 기본키 속성: 엔티티를 식별할 수 있는 속성
     - 외래키 속성: 다른 엔티티와의 관계에서 포함된 속성
     - 일반 속성: 엔티티에 포함되고 PK나 FK 속성이 아닌 속성
6. 도메인: 속성이 가질 수 있는 값의 범위

### 4절_관계

1. 정의 :: 엔티티 간의 논리적인 관련성, 동사형
2. 관계의 페어링 :: 인스턴스 간 개별적 관계 ?
3. 관계 표기법: 관계명 - 관계차수 - 관계선택사양
   - 관계차수(cardinality): 관계 내 튜플의 전체 개수. 1-직선, 다수-삼발
     - N:M 관계: 관계형 DB에서 N:M 조인은 카테시안 곱 발생
     - 관계선택사양: 필수 - |, 선택 - O
4. 종류
   - ERD 기준: 표기구분 하지 않음
     - 존재 관계: 엔티티 간의 상태
     - 행위 관계: 엔티티 간에 발생하는 행위
   - UML(Unified Modeling Language) 기준
     - 연관 관계: 실선 표기
     - 의존 관계: 점선 표기
   - 식별자에 따른 분류
     - 식별 관계: 부모 엔티티의 식별자를 자식 엔티티에서 주식별자로 사용
       - +) 약한 엔티티: 부모 엔티티에 종속되어 존재 (강한 엔티티는 독립적으로 존재)
     - 비식별 관계: 부모 엔티티의 식별자를 자식 엔티티의 일반 컬럼으로 참조 사용, 약한 종속 관계
       - FK를 말하는 건가?
       - +) 식별 관계만으로 연결되면 주식별자 수가 많아질 수밖에 없음
         - [관계 강약 분석, 자식 엔티티의 독립 PK 필요성, SQL 복잡성과 개발 생산성] 의 고려가 필요
5. 관계 읽기: 각각/하나의 -> 기준 엔티티 -> 관계차수 -> 대상 엔티티 -> 관계선택사양 -> 관계명

### 5절_식별자

1. 정의 :: 엔티티를 대표할 수 있는 유일성을 만족하는 속성
2. 특징: 유일성, 최소성, 불변성, 존재성
3. 종류
   - 대표성 여부에 따른 분류
     - 주식별자: 대표성을 만족하는 식별자
     - 보조 식별자: 유일성과 최소성만 만족하는 식별자, 참조 관계 연결에 사용할 수 없음
     - +) DB 키의 종류
       - 기본키 PK: 엔티티를 대표하는 키, 후보키 중에서 선정됨
       - 후보키: 유일성과 최소성을 만족하는 키
       - 슈퍼키: 유일성만 만족하는 키
       - 대체키: 기본키를 제외한 나머지 후보키
       - 외래키 FK: 여러 테이블의 기본 키 필드, 참조 무결성을 확인하기 위해 사용됨
   - 생성 여부에 따른 분류
     - 내부 식별자: 자연스럽게 존재하는 식별자
     - 외부 식별자: 다른 엔티티와의 관계를 통해 생성되는 식별자
   - 속성 수에 따른 분류
     - 단일 식별자: 하나의 속성
     - 복합 식별자: 여러 속성
   - 대체 여부에 따른 분류
     - 본질 식별자: 대체될 수 없는 식별자
     - 인조 식별자: 인위적으로 만들어지는 대체가능한 식별자 (순서번호 등)
       - 후보 식별자 중 주식별자로 선정할 것이 없거나
       - 주식별자가 너무 많은 칼럼으로 구성되어 있을 때 사용
4. 주식별자 도출 기준 :: 업무에서 자주 이용되는 속성, 이름 명명 지양, 복합 식별자 지양

## 2장_데이터 모델과 성능

### 1절_성능 데이터 모델링의 개요

1. 성능 데이터 모델링: DB 성능 향상을 위한 사항이 데이터 모델링에 반영되도록 하는 것
2. 수행 시점: 분석/설계 단계 - 성능 데이터 모델링 시점이 늦어질 수록 재업무 비용이 증가함
3. 고려 사항: 정규화 수행(필수), DB 용량 산정과 트랜잭션 유형 파악을 통한 반정규화 수행

### 2절_정규화와 성능

1. 정규화 :: 데이터 분해 과정, 이상현상 제거

   - 정규형: 정규화로 도출된 데이터 모델이 갖춰야 할 특성

2. 함수적 종속성 :: 결정자와 종속자의 관계, 결정자의 값으로 종속자의 값을 알 수 있음

   - 다치 종속: 여러 칼럼이 동일한 결정자의 종속자일 때

3. 정규화 이론

   1, 2, 3차, 보이스코드 정규화는 함수적 종속성에 근거
   4차 정규화는 다치 종속을 제거
   5차 정규화는 조인에 의한 이상현상을 제거하여 정규화를 수행함

   - **1차 정규화**: 속성의 원자성 확보 - 다중값 속성을 분리함
     - 과목: DB, C, OS => 분리
   - **2차 정규화**: 부분 함수 종속성 제거 - **일부 기본키**에만 종속된 속성을 분리함, 기본키가 하나의 칼럼일 때 생략 가능
     - [학생번호 - 과목]의 기본키를 가지는 테이블이 지도교수라는 속성을 가지면, 지도교수는 과목에만 종속되어 있음 => 분리
   - **3차 정규화**: 이행 함수 종속성 제거 - 서로 종속관계가 있는 일반속성을 분리함, 주식별자와 관련성이 가장 낮음
     - ID, 등급, 할인율을 속성으로 갖는 테이블이 있을 때 - ID를 알면 등급을 알 수 있고 등급을 알면 할인율을 알 수 있음(이행종속성),  => 분리
   - **보이스코드 정규화**: 후보키가 기본키 속성 중 일부에 함수적 종속일 때 다수의 주식별자를 분리함
     - [학생번호, 과목명, 지도교수] 속성을 가지는 테이블에서, 과목명으로는 지도 교수를 알 수 없지만 지도교수를 알면 과목명을 알 수 있는 상태라고 가정한다면 PK가 아닌 지도교수가 과목명의 결정자가 됨?
   - 4차 정규화, 5차 정규화: 다치 종속 분리, 결합 종속 분리

4. 정규화와 성능: 정규화는 입출력 데이터의 양을 줄여 성능을 향상시킴

   - 정규화로 인한 성능 향상: 입력/수정/삭제 시 성능 향상
     - 유연성 증가: High Cohesion & Loose Coupling 원칙에 충실
     - 재활용 가능성 증가: 개념이 세분화됨
     - 데이터 중복 최소화
   - 정규화로 인한 성능 저하: 조회 시 처리 조건에 따라 성능 저하가 발생할 수 있음
     - 데이터 조회 시 조인을 유발하여 CPU와 메모리를 많이 사용하게 됨
       - 반정규화로 해결 가능
       - 조인 발생시 인덱스를 사용하여 조인 연산을 수행하면 성능 상 단점이 거의 업속, 정규화를 통해 필요한 인덱스의 수를 줄일 수 있음
       - 정규화를 통해 테이블의 사이즈가 작아진다면 성능 상 유리할 수 있음

### 3절_반정규화와 성능

1. 반정규화 :: 데이터 중복을 허용하여 조인을 줄이는 DB 성능 향상 방법. 데이터의 무결성을 희생하고 조회 성능 향상

2. 절차

   1. 반정규화 대상 조사: 데이터 처리 범위 및 통계성 등 조사

   2. 다른 방법 검토

      뷰, 클러스터링, 인덱스, 애플리케이션

   3. 반정규화 적용: 정규화 수행 후 반정규화 수행

3. 기법

   - 테이블 반정규화
     - 테이블 병합
       - 1:1 관계 테이블 병합
       - 1:N 관계 테이블 병합: 많은 데이터 중복 발생
       - 슈퍼타입/서브타입 테이블 병합
     - 테이블 분할: 수직분할, 수평분할
     - 테이블 추가
       - 중복 테이블: 업무나 서버가 다를 때 중복 테이블 생성 (원격조인 제거)
       - 통계 테이블
       - 이력 테이블
       - 부분 테이블: 자주 이용하는 칼럼으로 구성된 테이블 생성
     - 칼럼 반정규화
       - 중복 칼럼 추가
       - 파생 칼럼 추가: 필요한 값 미리 계산한 칼럼 추가
       - 이력 테이블 칼럼 추가
       - PK에 의한 칼럼 추가: PK의 종속자를 일반속성으로 생성
       - 응용 시스템의 오작동을 위한 칼럼 추가
     - 관계 반정규화: 데이터 무결성 보장 가능
       - 중복 관계 추가

### 4절_대용량 데이터에 따른 성능

1. 블록 :: 테이블의 데이터 저장 단위
2. 대량 데이터 발생으로 인한 현상
   블록 IO 증가 -> 디스크 IO 가능성 상승 (성능 저하)
   - 로우 체이닝: 행 길이가 너무 길어 여러 블록에 걸쳐 저장되는 현상
   - 로우 마이그레이션: 수정된 데이터가 해당 블록이 아닌 다른 블록의 빈 공간에 저장되는 현상
3. 테이블 분할 :: 반정규화 기법
   - 수직분할: 너무 많은 수의 칼럼이 있는 경우 칼럼 단위로 테이블을 분할하여 IO를 감소
   - 수평분할: 행 단위로 테이블을 분할하여 IO를 감소시킴
4. 파티셔닝 :: 테이블 수평분할 기법. 논리적으로는 하나의 테이블이지만 물리적으로 여러 데이터 파일에 분산 저장, 데이터 조회 범위를 줄여 성능 향상
   - Range Partition: 데이터 값의 범위를 기준으로 분할
   - List Partition: 특정한 값을 기준으로 분할
   - Hash Partition: 해시 함수를 적용하여 분할, DBMS가 알아서 분할 관리. 데이터 위치를 알 수 없음
   - Composite Partition: 여러 기법을 복합적으로 사용하여 분할
   - +) 파티션 인덱스
     - Global Index: 여러 파티션에서 단일 인덱스 사용
     - Local Index: 파티션 별로 각자 인덱스 사용
     - Prefixed Index: 파티션키와 인덱스키 동일
     - Non-Prefixed Index: 파티션키와 인덱스키 구분

### DB 구조와 성능

1. 슈퍼타입/서브타입 데이터 모델 변환을 통한 성능 향상
   - 슈퍼타입/서브타입 데이터 모델: 속성을 할당하여 배치하는 수평 분할된 형태의 모델
     공통 속성은 슈퍼타입으로 모델링하고, 차이가 있는 속성은 서브타입으로 구분됨
     - 정확하게 업무를 표현할 수 있음
     - 물리적 모델링 시 선택의 폭을 넓힐 수 있음
   - 변환 기준: 데이터 양, 트랜잭션 유형
   - 변환 기술
     - 1:1 타입: 개별로 처리하는 트랜잭션에 대해 개별 테이블 구성, 슈퍼타입과 서브타입 각각 필요한 속성과 유형에 적합한 데이터만 가지도록 분리하여 1:1 관계를 갖도록 함
     - 슈퍼/서브 타입: 슈퍼타입과 서브타입을 공통으로 처리하는 트랜잭션에 대해 슈퍼타입과 서브타입 각각의 테이블 구성
     - All in One 타입: 일괄 처리하는 트랜잭션에 대해 단일 테이블 구성
2. PK/FK 칼럼 순서 조절을 통한 성능 향상 :: 등호 조건이나 BETWEEN 조건이 걸리는 칼럼을 앞으로 이동 (여러 조건 존재시 등호 조건이 걸리는 칼럼을 선두로)
3. 인덱스 특성을 고려한 PK/FK DB 성능 향상: 물리적인 테이블에 FK 제약을 걸어 인덱스를 생성

### 6절_분산 DB 데이터에 따른 성능

1. 분산 DB: 분산된 DB를 하나의 가상 시스템으로 사용할 수 있도록 한 DB. 물리적 위치는 분산되어 있으나 논리적으로는 동일한 시스템. 과거에는 위치 중심이었으나 현재는 업무 필요에 따라 분산 설계
   - 설계 방식
     - 상향식: 지역 스키마 작성 후 전역 스키마 작성
     - 하향식: 전역 스키마 작성 후 지역사상 스키마 작성
   - 장점
     - 신뢰성, 가용성 증가
     - 빠른 응답 속도와 통신비용 절감
     - 용량 확장 용이
   - 단점
     - 관리 및 통제 난이도
     - 데이터 무결성 관리 난이도
     - SW 개발 비용 및 처리 비용 증가
     - 불규칙한 응답 속도
2. 분산 DB의 투명성
   - 분할 투명성: 하나의 논리적 관계가 분할되어 각 단편의 사본이 여러 사이트에 저장됨
   - 위치 투명성: 사용하려는 데이터 저장 장소가 명시되지 않아도 됨
   - 지역사상 투명성: 지역 DBMS와 물리적 DB 사이의 사상이 보장됨
   - 중복 투명성: DB 객체 중복 여부를 몰라도 됨
   - 장애 투명성: 구성요소의 장애에 무관하게 트랜잭션의 원자성이 유지됨
   - 병행 투명성: 다수의 트랜잭션을 동시 수행했을 때 결과의 일관성이 유지됨
3. 분산 DB 적용 기법
   - 테이블 위치 분산: 설계된 테이블의 위치를 분산함
   - 테이블 분할 분산: 테이블을 쪼개어 분산함
     - 수평 분할/수직 분할
   - 테이블 복제 분산: 동일한 테이블을 다른 지역이나 서버에서 동시 생성함. 원격지 조인을 내부 조인으로 변경하여 성능 향상
     - 부분 복제/광역 복제
   - 테이블 요약 분산
     - 분석요약: 사이트 별 요약정보를 본사에서 통합하여 전체 요약정보 산출
     - 통합요약: 사이브 별 정보를 본사에서 통합하여 전체 요약정보 산출

---

## 1장_SQL 기본

### 1절_관계형 DB 개요

1. DB :: 데이터를 일정한 형태로 저장해 놓은 것. DBMS를 이용하여 효율적인 데이터 관리와 데이터 손상 복구 가능
   - 종류
     - 계층형 DB: 트리 형태의 자료구조에 데이터 저장. 1:N 관계 표현 가능
     - 네트워크형 DB: 오너와 멤버 형태로 데이터 저장. N:M 관계 표현 가능
     - 관계형 DB 릴레이션에 데이터 저장. 집합 연산/관계 연산 가능
2. 관계형 DB
   정규화를 통해 이상현상 및 중복 데이터 제거
   동시성 관리와 병행제어를 통해 데이터 동시 조작 가능
   - 집합 연산
     - 합집합
     - 차집합
     - 교집합
     - 곱집합: 각 릴레이션에 존재하는 모든 데이터를 조합
   - 관계 연산
     - 선택 연산: 조건에 맞는 행 조회
     - 투영 영상: 조건에 맞는 칼럼 조회
       - Projection
     - 결합 연산: 공통 속성을 사용하여 새로운 릴레이션 생성
     - 나누기 연산: 공통 요소를 추출하고 분모 릴레이션의 속성을 삭제한 후 중복된 행 제거
3. SQL :: RDB에서 사용하는 언어. 데이터 조회 및 신규 데이터 입력/수정/삭제 기능 제공
   - 종류
     - DML - 데이터 조작어
       - SELECT: 데이터 조회 명령어
       - INSERT, UPDATE, DELETE: 데이터 변형 명령어
     - DDL - 데이터 정의어
       - CREATE, ALTER, DROP
     - DCL - 데이터 제어어
       - GRANT, REVOKE
     - TCL - 트랜잭션 제어어
       - COMMIT, ROLLBACK
4. 테이블 :: RDB의 기본 단위. 데이터를 저장하는 객체, 칼럼과 행의 2차원 구조

### 2절_DDL

1. 데이터 타입 (Oracle / SQL Server)
   - CHAR(L): 고정 길이 문자열. 할당된 값의 길이가 L 이하일 때 차이는 공백으로 채워짐
   - VARCHAR2(L), VARCHAR(L): 가변 길이 문자열. 할당되는 변수 값의 길이의 최대값이 L. 가능한 최대 길이로 설정
   - NUMBER(L, D): 숫자형 (L은 전체 자리 수, D는 소수점 자리 수)
     - SQL Server는 NUMERIC DECIMAL FLOAT REAL 등
   - DATE, DATETIME: 날짜형. 데이터 크기 지정이 필요하지 않음
2. CREATE TABLE `>>> CREATE TABLE tableName columnName DataType constraints`
   - 테이블 및 칼럼 명명 규칙
     - 알파벳, 숫자, _, $, # 사용 가능
     - 대소문자 구분 없음
     - 테이블명은 단수형 권고
   - 제약조건: 데이터 무결성 유지가 목적. 복제 테이블에는 기존 테이블 제약조건 중 NOT NULL만 적용됨
     - Primary Key: 테이블 당 하나의 기본키만 정의 가능. 생성시 DBMS가 자동으로 인덱스를 생성함. NULL 불가
     - Foreign Key: 다른 테이블의 기본키를 외래키로 지정. 참조 무결성 제약조건
       `>>> ALTER TABLE tableName ADD CONSTRAINT columnName FOREIGN KEY (columnName) REFERENCES tableName(columnName)`
     - Unique Key: 행 데이터를 식별하기 위해 생성. NULL 가능
     - DEFAULT: 설정한 값을 기본값으로
     - NOT NULL: NULL과의 수치연산은 NULL, 비교연산은 FALSE 출력
       - NULL: 그냥 null
     - CHECK: 입력값의 종류 및 범위 제한
   - DESCRIBE 테이블명: 테이블 구조 확인
3. ALTER TABLE: 테이블의 칼럼 관련 변경 명령어
   - 칼럼 추가 `>>> ALTER TABLE tableName ADD (columnName DataType)`
     - 마지막 칼럼으로 추가됨(위치 지정 불가)
   - 칼럼 삭제 `>>> ALTER TABLE tableName DROP COLUMN columnName`
     - 삭제 후 복구 불가
   - 칼럼 설정 변경 `>>> ALTER TABLE tableName MODIFY (cName type const)`
     - 널만 있거나 행이 없는 경우에만 칼럼의 크기 축소 가능
     - 널만 있을 때는 데이터 유형 변경 가능
     - 널이 없으면 NOT NULL 제약조건 추가 가능
     - 기본값 변경 작업 이후 발생하는 데이터에 대해서만 기본값이 변경됨
   - 칼럼명 변경 `>>> ALTER TABLE tName RENAME COLUMN cName`
     - ANSI/ISO 표준에 명시된 기능 아님
   - 제약조건 추가 `>>> ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건`
   - 제약조건 제거 `>>> ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건`
4. RENAME TABLE `>>> RENAME tName TO tName` (ANSI/ISO 표준)
   - `>>> ALTER TABLE 테이블명 RENAME TO 테이블명` 로도 가능
5. DROP TABLE `>>> DROP TABLE tName`
   - 테이블의 데이터와 구조 삭제, 복구 불가
   - CASCADE CONSTRAINT 옵션으로 관련 테이블의 참조 제약조건도 삭제하여 참조 무결성을 준수할 수 있음
6. TRUNCATE TABLE `TRUNCATE TABLE tName`
   - 테이블의 전체 데이터 삭제
   - 로그를 기록하지 않기 때문에 ROLLBACK 불가

### 3절_DML

1. INSERT :: 데이터 입력 `>>> INSERT INTO tName () VALUES ()`
2. UPDATE :: 데이터 수정 `>>> UPDATE tName SET cName={value}`
3. DELETE :: 데이터 삭제 `DELETE FROM tName WHERE 조건절`
   - DELETE로 데이터를 삭제해도 테이블 용량은 초기화되지 않음 (<=> TRUNCATE)
   - DROP은 객체 삭제 명령어
4. SELECT
   - 칼럼 별 데이터 선택 `>>> SELECT cName FROM tName`
   - 데이터 중복 없이 선택 `>>> SELECT DISTINCT cName FROM tName`
   - 전체 칼럼의 데이터 선택 `>>> SELECT * FROM tName`
   - +) Alias
     - SELECT cNams AS “alias”: 출력되는 칼럼명 설정
     - FROM 테이블명 별명: 쿼리 내에서 사용할 테이블명 설정. 칼럼명이 중복될 경우 SELECT 절에서 alias 필수
5. 문자열의 합성 연산자: +, CONCAT 함수로 2개 문자열 합성 가능. Oracle에서는 ||도 가능
6. DUAL: Oracle의 기본 더미 테이블. 연산 수행을 위해 사용됨

### 4절_TCL

1. 트랜잭션 :: DB의 논리적 연산 단위. 하나 이상의 SQL문을 포함함
   - 특성 ACID
   - 원자성: 전부 실행되거나 전혀 실행되지 않음
   - 일관성: 트랜잭션으로 인한 DB 상태의 모순이 없음
   - 고립성: 부분적인 실행 결과에 다른 트랜잭션이 접근할 수 없음. LOCKING으로 고립성 보장
   - 영속성: 트랜잭션의 결과는 영구적으로 저장됨
2. TCL :: 데이터 무결성 보장을 목적으로 함.
   영구 변경 전 확인/연관 작업 동시 처리 가능
   - Oracle은 SQL 문장을 실행하면 트랜잭션 시작, TCL 실행 후 트랜잭션이 종료됨
   - DDL을 실행하면 자동 커밋 (DML 이후 커밋 없이 DDL을 실행해도 자동 커밋)
   - DB를 정상적으로 종료하면 자동 커밋. 애플리케이션 이상으로 DB 접속이 단절되면 자동 롤백
3. COMMIT :: 데이터를 DB에 영구적으로 반영하는 명령어. 커밋 시 트랜잭션이 완료되어 LOCKING이 해제됨. SQL Server는 기본적으로 자동 커밋
   - COMMIT 전
     - 데이터 변경이 메모리 버퍼에만 영향을 받았기 때문에 복구 가능(NOLOGGING 옵션 사용시 버퍼 캐시의 기록을 생략하여 입력 성능 향상)
     - 사용자는 SELECT절로 결과를 확인할 수 있으나 다른 사용자는 현재 결과를 볼 수 없음
     - 변경된 행에 LOCKING이 설정되어 다른 사용자가 변경할 수 없음 (LOCKING이 안 걸린 상태일 때 여러 사용자가 데이터를 변경하면 상관없음)
   - COMMIT 후
     - 변경 사항이 DB에 반영되고 이전 데이터는 복구 불가
     - 모든 사용자가 결과를 볼 수 있음
     - LOCKING이 해제되어 다른 사용자가 행을 조작할 수 있음
4. ROLLBACK :: 트랜잭션 시작 이전의 상태로 되돌리는 명령어. COMMIT 이전 상태로 돌려줌. ROLLBACK 시 LOCKING이 해제됨
   - SAVEPOINT: 트랜잭션 일부만 롤백할 수 있도록 중간상태를 저장하는 명령어. `>>> ROLLBACK TO 저장점1`. 동일한 저장점명이 있으면 나중 저장점이 유효.
   - SQL Server에서는 BEGIN TRAN으로 명시해야 가능

### 5절_WHERE절

1. WHERE `>>> SELECT cName FROM tName WHERE 조건절`
2. 연산자
   - 종류
     - 비교연산자: =, >, >=, <, <=
       - 자동으로 형변환 되는 경우 있음
     - 부정 비교 연산자: ‘NOT cName 비교연산자’
       - 부등호: !=, ^=, <>(ISO 표준)
     - SQL 연산자 입력값을 비교하여 논리값 출력
       - BETWEEN A AND B: A와 B 사잇값
       - IN 리스트: 리스트 내의 값
       - LIKE ‘문자열’: 문자열의 형태와 일치하는 값
         - 와일드카드: %는 0개 이상의 문자, _는 1개의 단일 문자
       - IS NULL: NULL은 등호로 판단 불가
       - NOT BETWEEN A AND B, NOT IN 리스트, IS NOT NULL
     - 논리 연산자: AND, OR, NOT
   - 우선순위: 부정 연산자 > 비교 연산자 > 논리 연산자
     - ()
     - NOT
     - 비교 연산자 및 SQL 연산자
     - AND
     - OR
   - 문자열 비교방법
     - CHAR vs. CHAR: 서로 다른 첫 문자열 값으로 비교(사전 순서로 뒷 순서가 더 큰 값), 길이가 다를 때 공백을 추가하여 길이를 맞춤(공백 수만 다르면 같은 값)
     - CHAR vs. VARCHAR: 서로 다른 첫 문자열 값으로 비교. 길이가 다르면 길이가 긴 값이 크다고 판단. VARCHAR의 공백도 문자로 판단, TRIM함수로 VARCHAR의 공백을 제거하고 판단할 수 있음
     - CHAR vs. 상수: 상수를 변수 타입으로 바꿔 비교
3. 부분 범위 처리
   - ROWNUM(Oracle): SQL 처리 결과 집합의 각 행에 임시로 부여되는 번호. 조건절 내에서 행의 개수를 제한하는 목적으로 사용함
   - TOP(SQL Server): 출력 행의 수 제한 함수. `>>> TOP n`으로 n개 행 출력. 개수 대신 비율로도 제한 가능
     - ORDER BY 절이 없으면 ROWNUM과 TOP의 기능이 같음

### 6절_함수

1. 단일 행 함수 :: SELECT, WHERE, ORDER BY 절에서 사용 가능. 각 행에 개별적으로 작용하며, 여러 인자를 입력해도 단 하나의 결과만 출력
   - 문자형 함수: 문자열 입력 시 문자열이나 숫자 반환
     - LOWER, UPPER, LENGTH
     - CONCAT: 문자열 결합
     - SUBSTR: 문자열 부분 추출
     - LTRIM, RTRIM, TRIM: 왼쪽 - 오른쪽 - 양쪽 공백 제거
     - ASCII: 아스키 코드값 출력
   - 숫자형 함수
     - ABS, SIGN: 절대값, 부호(1, 0 ,-1)
     - MOD: 나머지 연산자(%로 대체 가능)
     - ROUND, CEIL, FLOOR: 반올림, 올림, 버림 `f(E, N)`으로 소수점 이후 N번째 자리까지 출력
       - TRUNC: 숫자형 부분 추출
   - 날짜형 함수
     - SYSDATE: 현재 시간 출력(년 월 일 시 분 초)
     - EXTRACT: 날짜형 부분 추출 `>>> SELECT EXTRACT(부분 FROM SYSDATE) FROM DUAL`
     - +- 숫자 -> 일자 연산, +-숫자/24 -> 시간 연산
     - NEXT_DAY: 지정된 요일 첫 날짜 출력
   - 변환형 함수: 데이터 타입 변환, 명시적 형 변환 방식
     - TO_NUMBER, TO_CHAR, TO_DATE(Oracle): 문자열을 숫자로, 숫자나 날짜를 문자열로, 문자열을 날짜로
     - CAST, CONVERT(SQL Server)
   - NULL 관련 함수
     - NVL(col, v): NULL 값 변환
     - NVL2(col, v1, v2): NULL이면 v1, 아니면 v2 출력
     - NULLIF(v1, v2): 같으면 NULL 다르면 첫 값 출력
     - COALESCE(v, v, v, ...): NULL이 아닌 첫 값 출력
     - ISNULL(col, v): NULL이면 값으로 대치, 아니면 칼럼 값 출력
2. 데이터 변환
   - 명시적 형 변환
   - 암시적 형 변환: DBMS automatically converts data type
3. 조건문: IF - THEN - ELSE 형태
   - CASE WHEN 조건절1 THEN 출력값 1 ELSE 기본값 END: ELSE 생략 시 NULL 출력(아마도 ELSE 문으로 빠지는 경우에?)
     - +) CASE WHEN NULL THEN 출력값 ELSE 기본값 => 조건이 없으므로 모든 행에서 기본값 출력
       - NULL일 때를 처리하고 싶다면 WHEN col IS NULL로 수정
     - DECODE(col, cond1, v1, cond2, v2, ... , default): Oracle 함수, CASE문과 같음

### 7절_GROUP BY, HAVING 절

1. 집계 함수(aggregate function): 그룹별 결과 출력, 다중 행 함수 중 하나. GROUP BY 절이 없으면 그룹을 하는 기준이 존재하지 않아 에러 발생. WHERE 절에 사용 불가, 공집합에서도 연산을 수행함
   - ALL, DISTINCT: 전체 출력, 중복 제외 출력
   - SUM, AVG, MAX, MIN, VARIAN, STDDEV: NULL 제외하고 연산(<=> 숫자 연산은 NULL 출력)
   - COUNT: 행 수 출력
     - COUNT(*): NULL 포함
     - COUNT(표현식): NULL 제외
2. GROUP BY: 그룹 기준 설정, alias 사용 불가
3. HAVING: GROUP BY절에 의한 집계 데이터에 출력 조건을 걺(<=> WHERE 절은 SELECT 절에 조건을 걸기 때문에 제외된 데이터가 GROUP BY 대상이 아님). 일반적으로 GROUP BY 뒤에 위치함

### 8절_ORDER BY 절

1. ORDER BY: 특정 칼럼을 기준으로 정렬. 기본 정렬 기준은 오름차순
   - 칼럼명 - alias - 칼럼의 SELECT절 ㅅ ㅜㄴ서로 칼럼 지정 가능. SELECT절에 없는 칼럼도 지정이 가능하다. 하지만 GROUP BY절이 있으면 대상 칼럼만 지정 가능
   - Oracle은 NULL을 최대값으로 판단함 (<=> SQL Server는 최소값으로 판단함)
2. SELECT문 실행 순서
   - 테이블에서 출력 대상이 아닌 것은 제거하고 그룹핑해서 그룹핑된 값이 조건에 맞는 데이터를 계산 및 출력하고 정렬함
     - SELECT col AS alias
       - 5, 계산 및 출력
     - FROM table
       - 1, 우선 테이블을 정한 뒤
     - WHERE condition
       - 2, 출력 대상이 아닌 것 제외
     - GROUP BY col/expression
       - 3, 그룹화
     - HAVING condition
       - 4, 그룹화 된 값들 중 조건에 맞는 데이터를
     - ORDER BY col/expression
       - 6, 정렬

### 9절_조인

1. 조인: 여러 테이블을 연결 또는 결합하여 데이터를 출력하는 것. 일반적으로 PK나 FK의 연관성에 의해 성립
2. 등가 조인: 두 테이블의 칼럼 값이 정확히 일치하는 경우, 대부분 PK와 FK 관계를 기반으로 함. `SELECT cols FROM table1 col1, table2 col2 WHERE table1.col1 = table2.col2`
   - SELECT 대상 칼럼이 두 테이블 모두에 있는 경우 alias를 지정해야 함(양쪽 alias 모두 무관?)
3. 비등가 조인: 두 테이블의 칼럼 값이 정확하게 일치하지 않는 경우, 부등호나 BETWEEN 연산자를 통해 조인

## 2장_SQL 활용

### 1절_표준조인

1. SQL에서의 연산
   - 집합 연산
     - UNION: 합집합
     - INTERSECT: 교집합
     - MINUS(오라클) / EXCEPT: 차집합
     - CROSS JOIN: 곱집합(생길 수 있는 모든 데이터 조합)
   - 관계 연산
     - WHERE절: 조건에 맞는 행 조회
     - SELECT: 조건에 맞는 칼럼 조회
     - JOIN
     - (DIVIDE): 명령어는 없음. 공통 요소를 추출하고 분모 릴레이션의 속성을 삭제한 후 중복된 행 제거
2. ANSI/ISO SQL의 조인 형태: INNER, NATURAL, CROSS, OUTER
3. NATURAL JOIN :: 같은 이름을 가진 칼럼 전체에 대한 등가 조인. USING 조건절이나 ON 조건절 사용 불가, 같은 데이터 유형 칼럼만 조인 가능, alias나 테이블명 사용 불가 `>>> SELECT cols FROM t1 NATURAL JOIN t2`
   - 자연스러운 조인이니까 뭘 안 달아줘도 됨
4. INNER JOIN :: 행에 동일한 값이 있는 칼럼 조인. JOIN의 기본 옵션이며 USING 조건절이나 ON 조건절 필수. CROSS JOIN이나 OUTER JOIN과 동시 사용 불가, 두 테이블에 동일 이름 칼럼이 있을 경우 SELECT절에 alias 필수 `>>> SELECT cols FROM t1 A, t2 B WHERE A.col=B.col`
   `>>> SELECT cols FROM t1 A INNER JOIN t2 B ON A.col=B.col`(표준)
   - USING 조건절: 같은 이름을 가진 칼럼 중 등가 조인 대상 칼럼 선택, SQL Server에서는 지원하지 않음. 조건절에 alias나 테이블명 불가
     `>>> SELECT cols FROM t1 A JOIN t2 B USING (col)`
   - ON 조건절: 다른 이름을 가진 칼럼 간 조인 가능(alias, 테이블명 필수)
     `>>> SELECT cos FROM t1 A JOIN t2 B ON (A.col=B.col)`
5. CROSS JOIN :: 가능한 모든 조합으로 조인
   `>>> SELECT col FROM t1, t2` (조인 조건이 없을 때 발생, NATURAL JOIN은 명시해야 함)
6. OUTER JOIN :: 조인 조건에서 행에 동일한 값이 없는 칼럼 조인. USING 조건절이나 ON 조건절 필수
   - LEFT OUTER JOIN: 좌측 테이틉ㄹ 조회 후 우측 테이블 조인 대상 데이터 조회
     `>>> SELECT cols FROM t1 A, t2 B A.col=B.col(+)`
     `>>> SELECT cols FROM t1 A LEFT OUTER JOIN t2 B ON (A.col = B.col)`
   - RIGHT OUTER JOIN
   - FULL OUTER JOIN: LEFT와 RIGHT OUTER 조인 포함
     `>>> SELECT cols FROM t1 A FULL OUTER JOIN t2 B ON (A.col=B.col)`

### 2절_집합 연산자

1. 집합 연산자: 조인 없이 여러 테이블의 관련 데이터를 조회하는 연산자
2. UNION :: 합집합, 칼럼 수와 데이터 타입이 모두 동일한 테이블 간 연산만 가능
   `>>> SELECT col FROM t1 A WHERE 조건절 UNION SELECT t2 WHERE 조건절`
   - UNION ALL: 중복된 행도 전부 출력하는 합집합. 정렬하지 않음(UNION은 정렬을 유발함). 집합 연산자에 속함
     `>>> SELECT cos FROM t1 A WHERE 조건절 UNION ALL SELECT t2 WHERE 조건절`
3. INTERSECT :: 교집합
   `>>> SELECT cols FROM t1 A WHERE 조건절 INTERSECT SELECT t2 WHERE 조건절`
4. MINUS, EXCEPT :: 차집합
   `>>> SELECT cos FROM t1 A WHERE 조건절 MINUS SELECT t2 WHERE 조건절`

### 3절_계층형 질의와 셀프 조인

1. 계층형 질의 :: 계층형 데이터를 조회하기 위해 사용하며 Oracle에서 지원
   - 계층형 데이터: 엔티티를 순환관계 데이터 모델로 설계할 때 발생함
   - CONNECT BY: 트리 형태의 구조로 쿼리 수행 (루트 노드부터 하위 노드의 쿼리를 실행함) _상사 이름과 사람 이름을 조인하여 상사 밑에 넣기_
     - START WITH: 시작 조건 지정
     - CONNECT BY PRIOR: 조인 조건 지정
       - LEVEL: 검색 항목의 깊이, 최상위 == 1
       - CONNECT_BY_ROOT: 최상위 계층 값 표시
       - CONNECT_BY_ISLEAF: 최하위 계층 값 표시
       - SYS_CONNECT_BY_PATH: 계층 구조의 전개 경로 표시
     - CONNECT BY절의 루프 알고리즘 키워드
       - NOCYCLE: 순환구조의 발생지점까지만 전개
       - CONNECT_BY_ISCYCLE: 순환구조 발생지점 표시 (부모 노드와 자식 노드가 같을 때 1, 아니면 0 출력)
     - LPAD: 계층형 조회 결과를 명확히 하기 위해 사용 (LEVEL 값을 이용하여 결과 데이터 정렬)
2. SQL Server 계층형 질의: CTE로 재귀 호출
3. 셀프 조인: 한 테이블 내에서 두 칼럼이 연관 관계가 있는 경우 - alias 필수

### 4절_서브쿼리

1. 서브쿼리 :: 하나의 SQL문 안의 SQL문
2. 종류
   - 동작 방식에 따른 분류
     - 비연관 서브쿼리: 메인쿼리 칼럼을 가지고 있지 않는 서브쿼리. 메인쿼리에 값을 제공하기 위한 목적으로 주로 사용
       - Access Subquery: 제공자 역할
       - Filter Subquery: 확인자 역할
       - Early Filter Subquery: 데이터 필터링 역할
     - **연관 서브쿼리: 메인쿼리의 결과를 조건이 맞는지 확인하기 위한 목적으로 주로 사용함**
   - 반환 데이터 형태에 따른 분류
     - 단일 행 서브쿼리: 실행 결과가 1건 이하인 서브쿼리. 단일 행 비교 연산자와 함께 사용
     - 다중 행 서브쿼리: 실행 결과가 여러 건. 다중 행 비교 연산자 사용
       - +) 다중 행 비교 연산자
         - IN: 서브쿼리의 결과 중 하나의 값이라도 동일하다는 조건
         - ANY: 서브쿼리의 결과 중 하나의 값이라도 만족
         - ALL: 모든 결과값을 만족
         - EXISTS: 서브쿼리의 결과를 만족하는 값이 존재하는지를 확인
           `WHERE EXISTS (SELECT ~)`
     - 다중 칼럼 서브쿼리: 실행 결과로 여러 칼럼 반환. 주로 메인쿼리의 조건과 비교하기 위해 사용(비교하고자 하는 칼럼의 개수와 위치가 동일해야 함)
3. 스칼라 서브쿼리 :: 값 하나를 반환하는 서브쿼리 - SELECT 절에 사용하는 서브쿼리
4. 뷰 :: 가상의 테이블. FROM절에 사용하는 뷰는 인라인 뷰라고 함
   - 장점
     - 독립성: 테이블 구조 변경 자동 반영
       - 되게 독립적이지 않은데? 손 안탄다는 의미에서 독립적이라는 뜻인 것 같음
     - 편리성: 쿼리를 단순하게 작성할 수 있음. 자주 사용하는 SQL문의 형태를 뷰로 생성하여 사용할 수 있음
     - 보안성: 뷰를 생성할 때 칼럼을 제외할 수 있음
5. WITH: 서브쿼리를 이용하여 뷰로 사용할 수 있는 구문
   `WITH 뷰명 AS (SELECT ~)`

### 5절_그룹 함수

1. ANSI 표준 데이터 분석 함수: 집계 함수, 그룹 함수, 윈도우 함수
2. 그룹 함수: 합계 계산 함수, NULL을 빼고 집계함(집계 함수처럼). 결과값이 없는 행은 출력하지 않음
   - ROLLUP: GROUP BY로 묶인 칼럼의 소계 계산. 계층 구조로 GROUP BY의 칼럼 순서가 바뀌면 결과 값이 바뀜
   - CUBE: 조합 가능한 모든 값에 대해 다차원 집계
   - GROUPING SETS: 특정 항목에 대한 소계 계산, GROUP BY의 칼럼 순서와 무관하게 개별적으로 처리함
3. GROUPING: 그룹 함수에서 생성되는 합계를 구분해주는 함수, 소계나 합계가 계산되면 1 아니면 0 반환

### 6절_윈도우 함수

1. 윈도우 함수 :: 여러 행 같의 관계 정의 함수, **중첩 불가**
   - 순위 함수
     - RANK: 중복 순위 포함
     - DENSE_RANK: 중복 순위 무시 (중간 순위를 비우지 않음)
     - ROW_NUMBER: 단순히 행 번호 표시, **값에 무관**하게 고유한 순위 부여
   - 일반집계 함수: SUM, MAX, MIN, AVG, COUNT
   - 행 순서 함수
     - FIRST_VALUE, LAST_VALUE: 첫 값, 끝 값
     - LAG, LEAD: 이전 행, 이후 행(Oracle)
     - +) LEAD(E, A)는 E에서 A번째 행의 값을 호출하는 형태로도 쓰임
   - 비율 관련 함수
     - PERCENT_RANK(): 백분율 순서
     - CUME_DIST(): 현재 행 이하 값을 포함한 누적 백분율
       - 높은 값이면 100에 근접하겠네
     - NTILE(A): 전체 데이터 A등분
     - RATIO_TO_REPORT: 총합계에 대한 값의 백분율
2. 윈도우 함수 문법
   `SELECT F(A) OVER (PARTITION BY col ORDER BY col 윈도잉절) FROM t1`
   - PARTITION BY: 그룹 기존
   - ORDER BY: 순위 지정 기준
   - 윈도잉절: 함수의 대상이 되는 행 범위 지정
     - N PRECEDING, N FOLLOWING: N번째 앞 행, N번째 뒤 행
     - UNBOUNDED PRECEDING, UNBOUNDED FOLLOWING: 첫행 끝행
     - CURRENT ROW: 현재 행
   - ROWS, RANGE: 행 지정, 값의 범위 지정

### 7절_DCL

1. DCL :: 유저를 생성하거나 권한을 제어하는 명령어. 보안을 위해 필요

   - GRANT: 권한 부여
     `GRANT 권한 ON 오브젝트 TO 유저`
   - REVOKE: 권한 제거
     `REVOE 권한 ON 오브젝트 TO 유저`

2. 권한

   - SELECT, INSERT, UPDATE, DELETE, ALTER, ALL: DML 관련 권한
   - REFERENCES: 지정된 테이블을 참조하는 제약조건을 생성하는 권한
   - INDEX: 지정된 테이블에서 인덱스를 생성하는 권한

3. Oracle의 유저

   SCOTT: 테스트용 샘플

   SYS: DBA 권한이 부여된 최상위 유저

   SYSTEM: DB의 모든 시스템 권한이 부여된  DBA

4. ROLE :: 권한의 집합. 권한을 일일이 부여하지 않고 ROLE로 편리하게 여러 권한 부여 가능

### 8절_절차형  SQL

1. 절차형  SQL: 일반적인 개발언어처럼 절차지향적인 프로그램을 작성할 수 있도록 제공하는 기능
   - SQL문의 연속적인 실행 및 조건에 따른 분기처리를 이용하여 특정 기능을 수행하는 저장 모듈 생성 가능
   - PL/SQL (Oracle)
     - 블록 구조: 블록 내에 DML, 쿼리, IF, LOOP 등을 사용할 수 있음
       - Declare: 블록에서 사용할 변수나 인수에 대한 정의
       - Begin: 처리할  SQL문 정의
       - Exception: 블록에서 발생한 에러 처리 로직 정의,  optional
   - T-SQL(SQL Server)
2. 프로시저
3. 사용자 정의 함수: 절차형  SQL을 로직과 함께 DB 내에 저장해 놓은 명령문 집합. RETURN을 통해 반드시 하나의 값 반환(<=> 프로시저)
4. 트리거: DML문이 수행되었을 때 자동으로 동작하는 프로그램(<=> 프로시저는 EXECUTE로 실행), DCL, TCL 실행 불가(<=> 프로시저는 사용 가능)

