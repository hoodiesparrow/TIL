# 2817. 로또

> - 제한시간
>
>   1000 ms  
>
>  
>
> - 메모리제한
>
>   128 MB  
>
>  
>
> ### 문제
>
> 로또에서는 {1, 2, 3, ... , 48, 49} 번호 중에 6개를 선택해야 한다.
>
> 로또 번호를 선택하는 데는 여러 가지 전략이 있겠지만 우리는 49개의 수 중에서 K( 6 < K < 13)개가 이미 선택되어 있다고 가정하고 
>
> 이 선택된 수들로 만들 수 있는 로또 번호를 만들어 보기로 한다.
>
>  
>
> 예를 들어 K = 8이고 선택된 수들의 집합 S = {1,2,3,5,8,13,21,34} 라고 할 때, 
>
> 가능한 로또 번호는 [1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], ... [3,5,8,13,21,34]. 로 28개가 있다.
>
>  
>
> 수의 개수 K와 K개의 수가 주어질 때 가능한 로또 번호를 출력하는 프로그램을 작성하시오.
>
> 
>
> ### 입력형식
>
> 하나의 행에 정수가 주어진다. 첫 수는 수의 개수 K(6 < K <13) 이다.
>
> 이어서 공백으로 구분하여 K개의 자연수 Si( 1≤ Si ≤ 49)가 오름차순으로 정렬되어 주어진다.
>
> 
>
> ### 출력형식
>
> 주어진 K개의 수로 만들 수 있는 가능한 로또 번호를 행으로 구분하여 출력한다.
>
> 각 행의 수들과, 행으로 구분된 로또 번호들은 오름차순으로 출력되어야 한다.

```python
def combination(lev, comb):
    if len(comb) == 6:
        print(*comb)
        return
    if lev == N:
        return

    combination(lev + 1, comb + [arr[lev]])
    combination(lev + 1, comb)


arr = list(map(int, input().split()))
N = arr.pop(0)

combination(0, [])
```

list 에 concatenate시 주소가 달라지므로 각각 가지들에 부분집합이 저장되고, 로또 번호이므로 부분집합의 길이가 6일 때 출력과 리턴(리턴하지 않는 경우 탐색이 깊어지므로)을 같이 해주는 코드입니다.

다른 방법도 생각나서 시도해 보았습니다.

```python
def combination(lev):
    if sum(switch) == 6:
        for idx in range(N):
            if switch[idx]:
                print(arr[idx], end=' ')
        print()
        return

    if lev == N:
        return
    switch[lev] = 1
    combination(lev + 1)
    switch[lev] = 0
    combination(lev + 1)


arr = list(map(int, input().split()))
N = arr.pop(0)
switch = [0] * N

combination(0)
```

 이번에는 순열을 만들때와 비슷하게 재귀의 트리를 따라 switch가 변화되며 6개가 1이 되는 경우에 출력을 하는 코드입니다.



| **[Success](javascript:reinfo_forum('4840152',1))(100)** | 5MB  | 46ms | [Python3](javascript:newWin('4840152','sparrowhoodie','Source',800,600);) | 2021-06-16 15:12:01 |
| -------------------------------------------------------- | ---- | ---- | ------------------------------------------------------------ | ------------------- |
| **[Success](javascript:reinfo_forum('4840127',1))(100)** | 34MB | 41ms | [Python3](javascript:newWin('4840127','sparrowhoodie','Source',800,600);) | 2021-06-16 15:05:11 |

첫번째 결과는(두번째 코드) 함수의 인자로 부분집합을 주지 않아서 메모리를 덜 소모하는 대신, N이 길어질수록 switch 배열을 검사하는 반복문을 많이 돌게 되어 시간이 더 걸리는 모습입니다.

따라서 N이 길수록 switch 배열을 사용하는 코드가 느려질 것이라는 걸 알 수 있고, 부분집합의 길이가 길어질수록 부분집합을 인자로 넘기는 코드의 메모리 사용량이 많아질 것이라는 걸 추측할 수 있습니다.