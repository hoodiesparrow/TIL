# 2665. 미로만들기

> | 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
> | :-------- | :---------- | :--- | :--- | :-------- | :-------- |
> | 1 초      | 128 MB      | 6256 | 3103 | 2245      | 50.976%   |
>
> ## 문제
>
> n×n 바둑판 모양으로 총 n2개의 방이 있다. 일부분은 검은 방이고 나머지는 모두 흰 방이다. 검은 방은 사면이 벽으로 싸여 있어 들어갈 수 없다. 서로 붙어 있는 두 개의 흰 방 사이에는 문이 있어서 지나다닐 수 있다. 윗줄 맨 왼쪽 방은 시작방으로서 항상 흰 방이고, 아랫줄 맨 오른쪽 방은 끝방으로서 역시 흰 방이다.
>
> 시작방에서 출발하여 길을 찾아서 끝방으로 가는 것이 목적인데, 아래 그림의 경우에는 시작방에서 끝 방으로 갈 수가 없다. 부득이 검은 방 몇 개를 흰 방으로 바꾸어야 하는데 되도록 적은 수의 방의 색을 바꾸고 싶다.
>
> 아래 그림은 n=8인 경우의 한 예이다.
>
> ![img](https://www.acmicpc.net/upload/images/MW747ysuRPRpii4KaUvptRDAx46g.png)
>
> 위 그림에서는 두 개의 검은 방(예를 들어 (4,4)의 방과 (7,8)의 방)을 흰 방으로 바꾸면, 시작방에서 끝방으로 갈 수 있지만, 어느 검은 방 하나만을 흰 방으로 바꾸어서는 불가능하다. 검은 방에서 흰 방으로 바꾸어야 할 최소의 수를 구하는 프로그램을 작성하시오.
>
> 단, 검은 방을 하나도 흰방으로 바꾸지 않아도 되는 경우는 0이 답이다.
>
> ## 입력
>
> 첫 줄에는 한 줄에 들어가는 방의 수 n(1≤n≤50)이 주어지고, 다음 n개의 줄의 각 줄마다 0과 1이 이루어진 길이가 n인 수열이 주어진다. 0은 검은 방, 1은 흰 방을 나타낸다.
>
> ## 출력
>
> 첫 줄에 흰 방으로 바꾸어야 할 최소의 검은 방의 수를 출력한다.

```python
import sys
from collections import deque

N = int(input())
maze = [list(map(int, list(sys.stdin.readline().rstrip()))) for n in range(N)]

# BFS (Prim)
start = (0, 0)
drc = [(-1, 0), (1, 0), (0, -1), (0, 1)]

D = [[10e10] * N for n in range(N)]
Q = deque()
# r,c; flips
Q.append((start, 0))
while Q:
    position, flips = Q.popleft()
    r, c = position

    for dr, dc in drc:
        nr, nc = r + dr, c + dc
        if 0 <= nr < N and 0 <= nc < N:
            if not maze[nr][nc]:  # 검은방
                if D[nr][nc] > flips + 1:
                    D[nr][nc] = flips + 1
                    Q.append(((nr, nc), flips + 1))

            else:  # 흰방
                if D[nr][nc] > flips:
                    D[nr][nc] = flips
                    Q.append(((nr, nc), flips))

print(D[N - 1][N - 1])

```

- prim의 개념을 이용한 BFS로 풀이했다.
  - 보통의 BFS의 경우에는 visited 배열을 활용하여 방문한 것을 확인하는 데, 이 문제는 거리가 중요한 것이 아니라 모든 칸 마다 가장 적게 뒤집는 횟수를 알아내야 하기 때문에 조금 다른 방식으로 방문체크가 된다.
    - 모든 탐색들은 현재 뒤집은 횟수를 가지고 다니며 `D` 배열과 비교하며 자신이 더 적은 횟수라면 계속해서 탐색이 깊어지고, 그렇지 않다면 탐색이 끊어지게 된다. 따라서 왔던 칸이라도 더 적은 횟수로 도달했다면 다시 근방을 탐색해 나가고, 그렇지 않다면 더 이상 탐색이 깊어지지 않는다.
    - 만약 자신이 더 적은 횟수로 해당 칸에 도달했다면 해당 칸의 가능한 최소 뒤집음 횟수(`D`)를 업데이트 한다.
      - 모든 탐색의 가지가 끝나면 while문이 종료되고, `D`배열에는 모든 칸에 대해 (0, 0)에서 출발했을 때 최소로 뒤집으며 도달할 수 있는 횟수가 저장되게 된다.
        - N - 1열, N - 1행의 값이 정답이 된다. 