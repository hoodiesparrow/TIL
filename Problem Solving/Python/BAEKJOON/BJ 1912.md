# 1912. 연속합

> | 시간 제한             | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
> | :-------------------- | :---------- | :---- | :---- | :-------- | :-------- |
> | 1 초 (추가 시간 없음) | 128 MB      | 83531 | 26579 | 18360     | 30.859%   |
>
> ## 문제
>
> n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
>
> 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
>
> ## 입력
>
> 첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.
>
> ## 출력
>
> 첫째 줄에 답을 출력한다.

```python
N = int(input())
numbers = list(map(int, input().split()))
memo = [0] * N

for i in range(N):
    idx = i
    if not memo[i]:
        # if numbers[i] >= 1:
        memo[i] = numbers[i]
        while idx < N - 1:
            if memo[idx] + numbers[idx + 1] > numbers[idx + 1]:
                idx += 1
                memo[idx] = memo[idx - 1] + numbers[idx]
            else:
                break
                
print(max(memo))
```

처음에는 어떡하지 했지만 종이에 쓰고 손으로 더해보니 생각보다 간단한 dp문제였는데,

두가지 조건을 만족하면 memo배열에 합을 기록하면 된다.

- 첫번째 조건은 방문처리로, memo배열에 값이 기록되어 있다면 이미 해당 수가 포함된 최대값이 구해졌다는 뜻으로 다시 구하지 않아도 된다. 정확하게는 다시 해당 수부터 더해 나가도 저장된 수를 넘을 수 없다.
- 두번째 조건은 앞에서 온 값과 해당 값을 더한 값이 A, 해당 값이 B라고 했을 때 A > B가 성립해야 한다. 말인즉슨 더해서 효용이 있다면 더하면 된다. 
  - 음수의 경우에도 -1, -2와 같은 배열이 있다면 A = -1 + -2, B = -2로 A < B이므로 더이상 연산하지 않는다.

