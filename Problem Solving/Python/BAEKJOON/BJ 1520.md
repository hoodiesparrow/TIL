# 1520. 내리막길

> | 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
> | :-------- | :---------- | :---- | :---- | :-------- | :-------- |
> | 2 초      | 128 MB      | 39267 | 10552 | 7506      | 28.253%   |
>
> ## 문제
>
> 여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.
>
> ![img](https://www.acmicpc.net/upload/201004/1.PNG)
>
> 현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.
>
> ![img](https://www.acmicpc.net/upload/201004/2.png)
>
> ![img](https://www.acmicpc.net/upload/201004/3.PNG)
>
> 지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.
>
> ## 출력
>
> 첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.

```python
import sys


def dfs(position):
    r, c = position

    if r == R - 1 and c == C - 1:
        return 1

    if dp[r][c] != -1:
        # 기 처리된 노드는 다시 계산하지 않음
        return dp[r][c]

    # 방문하지 않은 것인지, 가망성이 없는 것인지 구분을 위해
    # dp배열을 -1로 초기화했기 때문에, 방문처리를 위해 0으로 설정합니다
    dp[r][c] = 0

    for dr, dc in drc:
        nr, nc = r + dr, c + dc
        if 0 <= nr < R and 0 <= nc < C:
            if board[r][c] > board[nr][nc]:
                dp[r][c] += dfs((nr, nc))
    return dp[r][c]


R, C = map(int, input().split())
board = [list(map(int, sys.stdin.readline().split())) for row in range(R)]
dp = [[-1] * C for row in range(R)]
drc = [(-1, 0), (1, 0), (0, 1), (0, -1)]

print(dfs((0, 0)))
```

오랜 시간동안 애를 먹인 문제이다. 어떻게 하면 연산량을 줄일 수 있을지의 방법론은 문제를 보면서 생각이 났지만, 코드로 구현이 잘 되지 않았다.

- 특히 친숙한듯 친숙하지 않은 재귀 구조가 필요하기에 더욱 어려웠던 것 같다.
  - while문 기반 dfs로는 처리가 난해하고 잘 되지 않았다.



- 원리는 간단하다.
  - A 노드에서 B 노드(자신보다 낮은 수)로 가는 것이 아니라, B 노드에 이미 (R - 1, C - 1)까지 도착하는 가짓수가 저장되어 있어서 그 값을 A로 가져와 (A와 인접한 상하좌우 노드들) 합산한 뒤 dp배열에 저장하는 것이다.
  - 이때 dp배열은 -1로 초기화하여 방문하지 않은 것인지, 가망성이 없는 것인지 구분한다.



- 많이 배울 수 있는 좋은 문제였다. 여러 번 복습 및 유사문제 풀이를 통해 숙달해야겠다.