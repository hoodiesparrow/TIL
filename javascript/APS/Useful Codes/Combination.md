# Combination

> 오랜만에 조합 문제를 풀었는데, 금방 생각이 나지 않아 검색해보니 이상한 코드들이 많아서 혼자 정리하는 용도



목적: 주어진 배열에서 **n개의 원소**를 가지는 **서로 다른** 하위 집합을 모두 도출한다.

### [1, 2, 3, 4], n = 2

- 배열이므로 각각의 원소는 인덱스를 이용해 원소를 표현한다.

  - 가능한 조합은 6개이다. (4 * 3 / 2)

    ```
    0 [1, 2, 3]
    1 [2, 3]
    2 [3]
    ```



이번에 정리할 구현 방법에서 사용할 아이디어

- 인덱스는 1씩 증가한다 -> for문 사용
- 배열을 다시 선언하지 않고 하나의 배열만 사용한다
- dfs식 재귀를 이용한다
  - 종료 조건이 만족되어 depth가 깊어졌던 함수가 다시 거슬러 올라올 때 삽입된 요소를 제거한다



전체 코드

```js
  function combination(comb, start = 0) {
    // basis
    if (comb.length === 2) {
      // 콜백함수 등 원하는 로직 실행
      return;
    }

    // recursive
    for (let idx = start; idx < population.length; idx += 1) {
      comb.push(population[idx]);
      combination(comb, idx + 1);
      comb.pop();
    }
  }

	combination([])
```

- basis: `comb`의 길이로 종료조건 판단

- recursive

  - 빈 배열을 받는다
  - for문이 돌며 배열의 첫 자리에는 0이 들어간다
  - 재귀하며 배열은 [0]에서 -> [0, 1]으로 변화한다
    - 배열의 두번째 요소가 1이 되기 위해서, combination()을 호출할 때 `idx + 1` 형태로 호출한다
    - 또한 이때는 comb.push(), combination() 까지만 코드가 실행된다
    - basis에 닿아 종료되면, 그 아래의 comb.pop()이 실행된다
    - 이때 배열은 [0]으로 회귀한다
    - 다음 for문이 실행되며 배열은 [0, 2] 와 같아진다
    - [0, 3] 이후, 가장 처음 push된 0이 pop() 되고 for문이 진행된다

  - 위의 동작을 [0, 1-3], [1, 2-3], [2, 3] 까지 반복한다.
  - [2, 4], [3] 과 같이 더 이상 실행될 수 없는 경우에는 for문이 실행되지 않아 종료된다



장점

- 배열을 다시 선언하지 않는다
- pop()을 쓰더라도, 맨 마지막 요소만 제거하기에 성능을 잡아먹지 않는다
- 짧다

개선 가능한 부분

- 탐색하지 않아도 되는 부분 가지치기
- basis 부분의 추상화

개선은 간단하지만 이해를 위해서 깔끔한 코드가 낫다고 생각

