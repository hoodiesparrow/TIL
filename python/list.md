> 0223 스터디 도중 나온 리스트 초기화 관련 코드에 대해서 정리하여 동기들과 공유하였습니다.



```python
arr1 = [0] * 10
arr1[1] = 1
print(id(arr1[0]), id(arr1[1]), id(arr1[2]))

print('*' * 30)

arr1_1 = [[0] * 10] * 10
arr1_1[1][1] = 1
print(id(arr1_1[0]), id(arr1_1[1]))
print(id(arr1_1[0][0]), id(arr1_1[1][0]))

print('*' * 30)

arr2 = [0 for n in range(10)]
arr2[1] = 1
print(id(arr2[0]), id(arr2[1]), id(arr2[2]))

print('*' * 30)

arr2_1 = [[0] * 10 for n in range(10)]
arr2_1[1][1] = 1
print(id(arr2_1[0]), id(arr2_1[1]))
print(id(arr2_1[0][0]), id(arr2_1[1][0]))

print('*' * 30)

arr3 = [0] * 10
print(id(arr1), id(arr3))
```

> #### 1차원 리스트, [0] * 10
>
> 140704512935568 140704512935600 140704447399568
>
> ******************************
> #### 2차원 리스트, [[0] * 10] * 10
>
> **2432890179328 2432890179328**
> 140704429770384 140704429770384
>
> ******************************
> #### 1차원 리스트, [0 for n in range(10)]
>
> 140704512935568 140704512935600  140704447399568
>
> ******************************
> #### 2차원 리스트, [[0] * 10 for n in range(10)]
>
> **2432890178944 2432890177472**
> 140704429770384 140704429770384
>
> ******************************
> <I>1790890298688 1790890017344</I>



1차원 리스트 안의 값은 값형으로 저장되어 리스트 주소로 참조된다



2차원 리스트 안의 값은 참조형 주소로 저장되어 리스트 주소로 참조된다.



코드를 연달아 실행해 보면, 진한 글씨는 계속해서 값이 변하는 현상을 관찰할 수 있는데, 이는 파이썬에서 255까지의 정수는 주소가 정해져 있으나 다른 자료형은 그렇지 않기 때문에 주소가 계속 변하는 것이다.



`*` 연산을 통해서 만들어진 2차원 리스트의 각 행들은 같은 주소를 공유하는 것을 볼 수 있는데,

이를 통해서 1차원 리스트를 `*`연산으로 만들 때도 참조하는 값의 주소를 복사하지만 1차원 리스트의 경우 값형이기 때문에 개별 요소를 수정하더라도 참조하는 객체를 수정할 수 없고(immutable) 다른 객체를 참조하는 것으로 처리되지만,

2차원 리스트를 `*`연산으로 처리하게 된다면 같은 주소를 복사해오더라도 2차원 리스트 안의 개별 행을 수정하게 되면, 참조형의 주소를 따라가 만난 리스트를 수정하게 되어 전체 행이 개별 행과 같은 데이터를 가지는 현상이 발생하는 것 같다.

아마도 for문을 통해 2차원 리스트를 생성할 때에는 `[0] * 10`를 한 번에 한 번씩 수행하여 2차원 리스트 안의 개별 행이 다른 주소를 가지게 되는 것이 아닐까?

에 대한 논리적 근거는,

맨 마지막에 이탤릭체로 눕혀진 두개의 1차원 리스트의 주소를 보면 확인할 수 있다.

똑같이 `[0] * 10` 의 연산을 통해 만들어진 리스트 `arr1`과 `arr3`이지만,  같은 연산임에도 따로 시행되었을 때, 리스트의 주소는 서로 다른 것을 확인할 수 있다.

