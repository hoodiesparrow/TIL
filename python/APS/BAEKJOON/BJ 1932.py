# 1932. 정수 삼각형

> | 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
> | :-------- | :---------- | :---- | :---- | :-------- | :-------- |
> | 2 초      | 128 MB      | 46619 | 27807 | 20542     | 59.559%   |
>
> ## 문제
>
> ```
>         7
>       3   8
>     8   1   0
>   2   7   4   4
> 4   5   2   6   5
> ```
>
> 위 그림은 크기가 5인 정수 삼각형의 한 모습이다.
>
> 맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.
>
> 삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.
>
> ## 입력
>
> 첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.
>
> ## 출력
>
> 첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.

```python
N = int(input())
memo = [0] * N
memo[0] = int(input())
for n in range(N - 1):
    arr = list(map(int, input().split()))
    length = len(arr)
    tmp = []
    for i in range(length):
        if i == 0:
            tmp.append(memo[0] + arr[0])
        elif i == length - 1:
            tmp.append(memo[i - 1] + arr[length - 1])
        else:
            tmp.append(max(memo[i - 1], memo[i]) + arr[i])
    for idx in range(len(tmp)):
        memo[idx] = tmp[idx]

print(max(memo))
```

파스칼의 삼각형? 과 비슷한 문제였다.

핵심은 각 단계마다 처음과 끝이 아닌 중간의 값들에는 현재 단계에서 고를 수 있는 최대값을 넘겨주면 된다는 점이다. memo배열을 길게 쓰기 싫어서 1차원으로 했더니 각 단계마다 tmp배열에 최대값을 저장한 후 다시 memo배열에 저장해주어야 했다. 

다른 사람들의 풀이를 보니 로직은 비슷하지만 구현이 제각각이라 다른 사람들의 코드를 볼 만한 가치가 있다고 생각된다.