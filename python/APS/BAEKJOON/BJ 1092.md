# 1092. 배

> | 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
> | :-------- | :---------- | :--- | :--- | :-------- | :-------- |
> | 2 초      | 128 MB      | 7203 | 1662 | 1213      | 24.725%   |
>
> ## 문제
>
> 지민이는 항구에서 일한다. 그리고 화물을 배에 실어야 한다. 모든 화물은 박스에 안에 넣어져 있다. 항구에는 크레인이 N대 있고, 1분에 박스를 하나씩 배에 실을 수 있다. 모든 크레인은 동시에 움직인다.
>
> 각 크레인은 무게 제한이 있다. 이 무게 제한보다 무거운 박스는 크레인으로 움직일 수 없다. 모든 박스를 배로 옮기는데 드는 시간의 최솟값을 구하는 프로그램을 작성하시오.
>  
>
> ## 입력
>
> 첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 각 크레인의 무게 제한이 주어진다. 이 값은 1,000,000보다 작거나 같다. 셋째 줄에는 박스의 수 M이 주어진다. M은 10,000보다 작거나 같은 자연수이다. 넷째 줄에는 각 박스의 무게가 주어진다. 이 값도 1,000,000보다 작거나 같은 자연수이다.
>
> ## 출력
>
> 첫째 줄에 모든 박스를 배로 옮기는데 드는 시간의 최솟값을 출력한다. 만약 모든 박스를 배로 옮길 수 없으면 -1을 출력한다.

```python
N = int(input())
cranes = list(map(int, input().split()))
M = int(input())
boxes = list(map(int, input().split()))
visited = [0] * (M + 1)
index = [M] * N
if max(cranes) < max(boxes):
    print('-1')
else:
    boxes.sort(reverse=True)
    cranes.sort(reverse=True)

    # 자리 잡아주기
    # 자리 잡을 때 작은 게 없으면 끝으로 보내기
    for crane_idx in range(N):
        for idx in range(M):
            if cranes[crane_idx] >= boxes[idx]:
                index[crane_idx] = idx
                break

    time = 0
    done = 0
    while not done:
        done = 1
        for crane_idx in range(N):

            if index[crane_idx] < M:
                # 크레인 자리 옮기기
                while visited[index[crane_idx]]:
                    index[crane_idx] += 1

                # 끝까지 온 경우 해당 탐색은 여기서 종료 (뒤에는 안 봐도 괜찮음)
                if index[crane_idx] == M:
                    break
                else:
                    visited[index[crane_idx]] = 1
                    index[crane_idx] += 1
                    done = 0
                    continue

            else:
                break

        if done == 1:
            pass
        else:
            time += 1

    print(time)
```

오랜만에 알고리즘 문제를 풀어봤다. 관통 프로젝트가 끝나고 푹 쉬었으니 다시 꾸준히 공부해야겠다!



- 크레인과 화물을 무게순으로 내림차순 정렬했다.
  - 개별 크레인이 처리할 수 있는 가장 무거운 화물부터 처리해야 가장 빠르게 일을 끝낼 수 있다.
  - 각자 시작하는 위치를 잡아준 뒤 방문처리를 이용하여 중복되지 않게 일을 처리하도록 했다.
    - 화물은 M개인데, 방문처리 리스트의 길이를 M+1로 설정하여 크레인이 처리할 화물을 지정해주는 `while visited[index[crane_idx]]:` 문에서 오류가 나지 않도록 했다. (방문처리 배열의 M번 인덱스는 0으로 초기화된 이후 바뀌지 않는다.)
  - 모든 화물의 무게보다 작은 무게 제한을 가진 크레인이 일을 하면 안되기 때문에 자리를 지정하는 `index`배열은 M으로 초기화했다.
    - `index`배열의 값이 M이면 해당 크레인 이후부터는 처리하지 않는다. (`break`)



- 크레인의 수가 50개이고, 화물이 10,000개이기 때문에 모든 크레인의 무게 제한이 최대이고 10,000개의 화물의 무게가 1인 경우가 최악의 경우이다.
  - 해당 케이스는 한번 시행에 50*50(자리를 50번씩 옮겨야 한다)번을 연산해야 하며, 전체 시행은 200번 반복된다(10,000 / 50)
    - 따라서 500,000번 정도 코드를 반복하게 되지만 제한시간이 2000ms이므로 충분하다고 판단후 해당 코드를 작성했다. (실 소요시간 `116ms`)
      - 만약 시간이 모자란다면 현재 크레인의 자리를 (앞 크레인의 자리 +1)로 만들어준다면 시간을 줄일 수 있을 것 같다.