# 25.02.2021

> 오늘은 내일 IM시험 대비 자습시간을 가졌다.



SWEA 1859. 백만장자 프로젝트

>   1. 원재는 연속된 N일 동안의 물건의 매매가를 예측하여 알고 있다.
>
> 2. 당국의 감시망에 걸리지 않기 위해 하루에 최대 1만큼 구입할 수 있다.
> 3. 판매는 얼마든지 할 수 있다

```python
for t in range(int(input())):
    N = int(input())
    arr = list(map(int, input().split()))

    start, end = 0, 0
    total = 0
    while start != N:
        M = max(arr[start:])
        idx = arr[start:].index(M)
        end = start + idx

        deduct = 0
        for i in range(start, end):
            deduct += arr[i]

        total += (end - start) * M - deduct
        start = end + 1

    print("#{} {}".format(t + 1, total))
```

- 처음에 이런 식으로 앞에서부터 읽어가는 느낌으로 풀이를 시작했는데, 계속해서 에러가 났다.
- 분명히 복잡한 테스트 케이스에서도 잘 작동했는데 왜 오류가 나는건지 계속 봐도

이해가 안됐었는데, 알고보니 메모리 제한을 넘어서 답이 맞아도 오류가 나는 거였다.

- 교수님이 뒤에서부터 해보는 것이 어떠냐고 하셔서 

  ```python
  for t in range(int(input())):
      N = int(input())
      arr = list(map(int, input().split()))
      total = 0
      current_max = 0
      deduct = 0
      cnt = 0
      idx = N
  
      while True:
          idx -= 1
          if arr[idx] >= current_max:
              total += current_max * cnt - deduct
              current_max = arr[idx]
              deduct = 0
              cnt = 0
          else:
              deduct += arr[idx]
              cnt += 1
  
          if idx == 0:
              total += current_max * cnt - deduct
              break
      print("#{} {}".format(t + 1, total))
  ```

  - 이런 식으로 뒤에서부터 읽어가는 식으로 했더니 잘 풀렸다.



SWEA 5789. 현주의 상자 바꾸기

>현주는 1번부터 N번까지 N개의 상자를 가지고 있다. 각 상자에는 숫자를 새길 수 있는데 처음에는 모두 0으로 적혀있다.
>
>숫자가 너무 단조로웠던 현주는 다음 Q회 동안 일정 범위의 연속한 상자를 동일한 숫자로 변경하려고 한다. 변경하는 방법은 다음과 같다.
>
>  · i (1 ≤ i ≤ Q)번째 작업에 대해 L번 상자부터 R번 상자까지의 값을 i로 변경

```python
for t in range(int(input())):
    N, Q = map(int, input().split())
    box = [0] * N
    for i in range(1, Q + 1):
        L, R = map(int, input().split())
        for j in range(R - L + 1):
            box[L + j - 1] = i

    print("#{}".format(t + 1), end=' ')
    print(*box)
```

- 전에 풀어 본 문제이고, 복잡하지 않아서 금방 풀었다.





SWEA 2805. 농작물 수확하기

>   ① 농장은 크기는 항상 홀수이다. (1 X 1, 3 X 3 … 49 X 49)
>
>   ② 수확은 항상 농장의 크기에 딱 맞는 정사각형 마름모 형태로만 가능하다.

```python
for t in range(int(input())):
    N = int(input())
    arr = [list(map(int, list(input()))) for n in range(N)]

    mid = N // 2
    s = mid
    e = mid
    r = 0
    total = 0
    while r != N:
        total += sum(arr[r][s:e + 1])
        if r < mid:
            s -= 1
            e += 1
        else:
            s += 1
            e -= 1
        r += 1

    print("#{} {}".format(t+1, total))
```

- 이 문제도 전에 풀어 본 문제이지만 이번에는 더 쉽게 풀렸다.





SWEA 1974. 스도쿠 검증

```python
for t in range(int(input())):
    arr = [list(map(int, input().split())) for n in range(9)]

    validity = 1
    # 가로검사
    for r in range(9):
        visited = [0] * 10
        for c in range(9):
            visited[arr[r][c]] += 1
        for n in range(1, 10):
            if visited[n] != 1:
                validity = 0

    # 세로검사
    for c in range(9):
        visited = [0] * 10
        for r in range(9):
            visited[arr[r][c]] += 1
        for n in range(1, 10):
            if visited[n] != 1:
                validity = 0

    # 정사각형 검사
    # 0,0 0,3 0,6
    # 3,0 3,3, 3,6
    # 6,0, 6,3 6,6
    dr, dc = 0, 0
    while dr != 9:
        visited = [0] * 10
        for r in range(dr, dr + 3):
            for c in range(dc, dc + 3):
                visited[arr[r][c]] += 1

        for i in range(1, 10):
            if visited[i] != 1:
                validity = 0
                break

        dc += 3
        if dc == 9:
            dc = 0
            dr += 3

    print(f'#{t+1} {validity}')
```

- 역시 저번에 풀어본 문제지만, 다시 푸니 수월하게 풀렸다.





SWEA 1860. 진기의 최고급 붕어빵

```python
for t in range(int(input())):
    print("#{}".format(t + 1), end=' ')
    N, M, K = map(int, input().split())
    arrival = list(map(int, input().split()))
    end = max(arrival)
    amt = 0
    time = 0
    cycle = 1
    possibility = 1
    arrival.sort()
    idx = 0
    while time != end + 1:
        if time == cycle * M:
            amt += K
            cycle += 1

        if arrival[idx] == time:
            mouth = arrival.count(time)
            amt -= mouth
            idx += mouth

        if amt < 0:
            possibility = 0
            break

        time += 1

    if possibility:
        print('Possible')
    else:
        print('Impossible')

```

- `if time == cycle * M:` cycle 개념을 넣어서 시간 흐름과 붕어빵 생산을 구현했다.





SWEA 4408. 자기 방으로 돌아가기

```python
for t in range(int(input())):
    queue = [0] * 200
    N = int(input())
    for n in range(N):
        depart, destination = map(int, input().split())

        if depart % 2:
            depart //= 2
        else:
            depart = depart // 2 - 1

        if destination % 2:
            destination //= 2
        else:
            destination = destination // 2 - 1

        if depart <= destination:  # 오른쪽
            for i in range(depart, destination + 1):
                queue[i] += 1
        else:
            for i in range(depart, destination - 1, -1):
                queue[i] += 1

    print("#{} {}".format(t + 1, max(queue)))
```

- 문제 이해하는 데 시간이 많이 걸렸지만, 실제 코드는 그렇게 어려운 코드 없이 그저 지점들에 대해서 몇명이 지나가는지를 누적하고, 누적된 값의 최댓값을 출력하는 것이 끝이다.