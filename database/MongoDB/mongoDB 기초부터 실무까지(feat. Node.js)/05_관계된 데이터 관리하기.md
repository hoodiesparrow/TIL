# Blog 모델 생성

```js
const { Schema, model, Types } = require('mongoose')

const BlogSchema = new Schema({
  title: { type: String, required: true },
  content: { type: String, required: true },
  isLive: { type: Boolean, required: true, default: false },
  user: { type: Types.ObjectId, required: true, ref: 'user' },
}, { timestamps: true })

const Blog = model('blog', BlogSchema)

module.exports = { Blog }
```

- `isLive`는 블로그 글의 임시 저장 여부를 확인하기 위한 속성이다.
- `user: { type: Types.ObjectId, required: true, ref: 'user' },` 구문에서 관계성을 형성하는데, `ref` 속성의 값은 `User.js`의 모델에서 사용한 이름과 같아야 한다. const User = model('**user**', UserSchema)
  - `ObjectId`를 type으로 쓰기 위해 import할 때 `Types`  또한 가져왔다.



```js
const { Router } = require('express')
const res = require('express/lib/response')
const { isValidObjectId } = require('mongoose')
const blogRouter = Router()
const { Blog } = require('../models/Blog')
const { User } = require('../models/User')

blogRouter.post('/', async(req, res) => {
  try {
    const { title, content, isLive, userId } = req.body
    if (typeof title !== 'string') 
      return res.status(400).send({ error: 'title is required' });
    if (typeof content !== 'string') 
      return res.status(400).send({ error: 'content is required' });
    if (isLive && typeof isLive !== 'boolean') 
      return res.status(400).send({ error: 'isLive must be a boolean' });
    if (typeof userId !== 'string') 
      return res.status(400).send({ error: 'user is required' });
    if (!isValidObjectId(userId)) 
      return res.status(400).send({ error: 'user ID is invalid' });

    let user = await User.findById(userId)
    if (!user) 
      return res.status(400).send({ error: 'user does not exist' });
    
    let blog = new Blog({ ...req.body, user })  // userid를 빼서 저장해줌
    await blog.save()
    return res.send({ blog })
  } catch(err) {
    console.log(err)
    return res.status(500).send({ error: err.message })
  }
})
```

blogRouter.js 파일 생성 후 블로그 작성 api를 만들었다.

- 이때 `new Blog()` 생성자가 실행될 때 timestamp가 기록되며, `save()`시에는 mongoose가 `user` 객체에서 `_id`를 추출해서 `insertOne` 쿼리를 보내게 된다.
  - NOTE:  `user` 객체를 넣으나 `user: userId` ID만을 넣으나 DB에 저장은 똑같이 되지만, client가 수신하는 response에는 객체를 넣는 경우 `user`의 전체 정보가, ID만을 넣는 경우에는 ID만 들어있다.



